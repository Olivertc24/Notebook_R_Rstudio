---
title: "M√≥dulo 4: Importaci√≥n y Exportaci√≥n"
subtitle: "Trayendo el mundo real a R"
author: "Prof. Oliver Trive√±o"
format: 
  revealjs:
    theme: simple
    transition: slide
    slide-number: true
    logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/724px-R_logo.svg.png"
    footer: "Input / Output en R"
    echo: true
    highlight-style: github
editor: visual
lang: es
---

## El Ciclo de Vida del Dato

R rara vez genera sus propios datos desde cero. Lo normal es un flujo **ETL**:

1.  **Extract (Importar):** Leer desde CSV, Excel, SQL.
2.  **Transform (Procesar):** Limpiar y analizar (R).
3.  **Load (Exportar):** Guardar resultados o reportes.

::: callout-note
**Prerrequisito:** Siempre verifica tu "Directorio de Trabajo" (`getwd()`) para saber d√≥nde busca R los archivos.
:::

------------------------------------------------------------------------

## 1. Archivos Planos (.csv / .txt)

Son el est√°ndar universal. Tenemos dos formas de leerlos:

::::: columns
::: {.column width="50%"}
**Base R (`utils`)** Viene instalado por defecto.

```{r}
#| eval: false
datos <- read.csv("archivo.csv")
```

Devuelve: Data Frame.
:::

::: {.column width="50%"}
Paquete readr M√°s r√°pido y no convierte texto a factores autom√°ticamente.

```{r}
#| eval: false
library(readr)
datos <- read_csv("archivo.csv")
```

Devuelve: Tibble (Data Frame moderno).
:::
:::::
------------------------------------------------------------------------

## 1. Archivos Planos (.csv / .txt)

* **Argumentos frecuentes:**
  * header: indica si la primera fila son nombres de columnas.
  * sep: separador (, para CSV, "\t" para TSV).
  * stringsAsFactors = FALSE: evita convertir cadenas en factores autom√°ticamente (en versiones recientes de R esto ya no es predeterminado).
  
------------------------------------------------------------------------

## 1. Archivos Planos (.csv / .txt)

* **Argumentos frecuentes:**
  * na.strings = c("", "NA"): c√≥mo interpretar valores faltantes.
  * colClasses = c("integer", "character", "numeric", ...): forzar clases de columnas si se conoce de antemano.
* **Paquete readr (parte del tidyverse)**
  * Ventajas: mayor velocidad, detecci√≥n autom√°tica de tipos, funcionalidad de parsers robustos.

------------------------------------------------------------------------

## 1. Archivos Planos (.csv / .txt)

* **Argumentos clave:**
  * col_types: cadena que especifica tipos de columnas ("c" para character, "i" para integer, "d" para double, "l" para l√≥gico).
  * skip = n: omitir primeras n l√≠neas (√∫til si el archivo tiene metadatos antes de la tabla).
  * n_max = k: leer s√≥lo las primeras k filas (√∫til para verificar estructura).
  
------------------------------------------------------------------------

## 1. Archivos Planos (.csv / .txt)

* **Manejo de valores faltantes**
  * En read.csv(): na.strings = c("", "NA", "NULL").
  * En read_csv(): na = c("", "NA").

------------------------------------------------------------------------

## 2. Archivos de Excel (.xlsx)

Para el mundo actual, Excel es inevitable. Usamos el paquete readxl.

```{r}
#| eval: false
library(readxl)

# Leer la primera hoja
siniestros <- read_excel("base_siniestros.xlsx")

# Leer una hoja espec√≠fica por nombre o √≠ndice
reservas <- read_excel("base_siniestros.xlsx", 
                       sheet = "Reservas_2025")
```

::: callout-tip
A diferencia de CSV, readxl puede detectar autom√°ticamente los tipos de datos de las celdas de Excel.
:::

------------------------------------------------------------------------

## 2. Archivos de Excel (.xlsx)

* **Argumentos clave:**

  * sheet: puede ser nombre o √≠ndice de la hoja (1, 2, ‚Ä¶).
  * range: rango de celdas (p. ej., "B2:E50").
  * col_names = TRUE/FALSE: si la primera fila tiene nombres.

------------------------------------------------------------------------

## 3. Conexi√≥n a Bases de Datos (SQL)

R se conecta, no copia. Usamos DBI (interfaz gen√©rica) y un conector espec√≠fico (ej. RSQLite, RPostgres).

```{r}
#| eval: false
library(DBI)
library(RSQLite)

# 1. Crear conexi√≥n
con <- dbConnect(RSQLite::SQLite(), "mi_base.db")

# 2. Consultar con SQL directo
df_clientes <- dbGetQuery(con, "SELECT * FROM clientes WHERE edad > 30")

# 3. Cerrar conexi√≥n (¬°Importante!)
dbDisconnect(con)
```

------------------------------------------------------------------------

## 4. Archivos Web (JSON / XML)

Muy usados en APIs y desarrollo web.

JSON (JavaScript Object Notation) Es una estructura jer√°rquica (parecida a las listas en R).

```{r}
#| eval: false
library(jsonlite)

# Leer desde una URL o archivo
datos_api <- fromJSON("[https://api.ejemplo.com/datos.json](https://api.ejemplo.com/datos.json)")

# jsonlite intenta convertirlo a Data Frame autom√°ticamente
head(datos_api)
```

------------------------------------------------------------------------

## 5. Exportaci√≥n de Datos

Despu√©s de analizar, debemos guardar los resultados limpios.

### A CSV (Universal)

```{r}
#| eval: false
# Base R
write.csv(datos_limpios, "resultados.csv", row.names = FALSE)

# readr (M√°s r√°pido, sin nombres de filas por defecto)
write_csv(datos_limpios, "resultados_v2.csv")
```

### A Excel

Requiere paquete writexl.

```{r}
#| eval: false
library(writexl)
write_xlsx(list(Hoja1 = df1, Hoja2 = df2), "reporte_final.xlsx")
```

# 6. Aspectos pr√°cticos de calidad de datos:

* **Verificar tipos de variables**
  * sapply(df, class) devuelve la clase de cada columna

------------------------------------------------------------------------

# 6. Aspectos pr√°cticos de calidad de datos:

* **Detectar valores faltantes y caracteres extra√±os**  
  * summary(df)            muestra conteos de NA, m√≠nimos, m√°ximos
  * any(is.na(df))         TRUE si hay al menos un NA en todo el data frame
  
------------------------------------------------------------------------

# 6. Aspectos pr√°cticos de calidad de datos:

* **Transformar fechas con lubridate**
  * Instalaci√≥n: install.packages("lubridate") 
  * cargar: library(lubridate)
  
------------------------------------------------------------------------

# 6. Aspectos pr√°cticos de calidad de datos:  

* **Transformar fechas con lubridate**
  * Funciones comunes:
    * fechas1 <- ymd("2020-01-15")      # A√±o-Mes-D√≠a
    * fechas2 <- dmy("15/02/2021")      # D√≠a-Mes-A√±o
    * fechas3 <- mdy_hms("03-12-2022 14:30:00")  # Mes-D√≠a-A√±o hora:minuto:segundo
    
------------------------------------------------------------------------

# 6. Aspectos pr√°cticos de calidad de datos:

* **Transformar fechas con lubridate**
  * Extraer componentes:
    * year(fechas1)    # 2020
    * month(fechas2)   # 2

------------------------------------------------------------------------

# 6. Aspectos pr√°cticos de calidad de datos:

* **Transformar fechas con lubridate**
  * Extraer componentes:
    * day(fechas3)     # 3
    * hour(fechas3)    # 14
    * wday(fechas3)    # d√≠a de la semana (1 = domingo)
    
------------------------------------------------------------------------

# 6. Aspectos pr√°cticos de calidad de datos:

* **Transformar fechas con lubridate**  
  * Transformar fechas en variables categ√≥ricas (p. ej., ‚Äúfin de semana‚Äù vs ‚Äúd√≠a laborable‚Äù):
    * df\$dia_semana <- wday(df\$fecha, label = TRUE)
    * df\$es_labo* <- df\$dia_semana %in% c("Mon", "Tue", "Wed", "Thu", "Fri")
    * df\$es_finde* <- df\$dia_semana %in% c("Sat", "Sun")


::: {style="position: fixed; bottom: 30px; right: 30px; z-index: 1000;"}
<a href="../index.qmd" class="btn btn-primary shadow-lg" role="button" style="border-radius: 50px; padding: 10px 20px;"> üè† Inicio </a>
:::
