---
title: "Módulo 7: Programación Funcional"
subtitle: "Control de Flujo y Automatización"
author: "Prof. Oliver Triveño"
format: 
  revealjs:
    theme: simple
    transition: slide
    slide-number: true
    logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/724px-R_logo.svg.png"
    footer: "Funciones y Loops en R"
    echo: true
    highlight-style: github
editor: visual
lang: es
---

## Objetivo

Automatizar tareas repetitivas y tomar decisiones lógicas.

> "Si te encuentras copiando y pegando el mismo código más de dos veces, es hora de escribir una función."

---

## 1. Estructuras de Control (`if`, `else`)

Permiten ejecutar código solo si se cumple una condición.

```{r}
#| label: if-else

siniestro <- 15000
limite <- 10000

if (siniestro > limite) {
  mensaje <- "Alerta: Siniestro excede el límite"
  prioridad <- "Alta"
} else if (siniestro == limite) {
  mensaje <- "En el límite exacto"
  prioridad <- "Media"
} else {
  mensaje <- "Siniestro dentro de parámetros"
  prioridad <- "Baja"
}

print(paste(mensaje, "-", prioridad))
```

---

### La versión Vectorizada: ifelse()

En R, rara vez usamos if dentro de un bucle para una columna entera. Usamos ifelse().

```{r}
#| label: ifelse-vec

# Vector de siniestros
montos <- c(500, 12000, 800)

# ifelse(test, si_verdadero, si_falso)
status <- ifelse(montos > 10000, "Revisar", "Aprobar")

status
```

---

## 2. Bucles (Loops)

Los bucles for y while son útiles para simulaciones o tareas recursivas.

```{r}
#| label: for-loop

# Calcular crecimiento de una inversión año a año
capital <- 1000
tasas <- c(0.05, 0.03) # Tasas variables

for (tasa in tasas) {
  interes <- capital * tasa
  capital <- capital + interes
  print(paste("Capital acumulado:", round(capital, 2)))
}
```

::: {.callout-warning} 
¡Ojo! En R, evita los bucles for si puedes hacer la operación directamente sobre el vector (vectorización). Es mucho más lento iterar fila por fila. 
:::

---

## 3. Funciones Personalizadas

La base de la programación robusta. Estructura:

```{r}
nombre <- function(argumentos) {
  # cuerpo del código
  return(resultado)
}
```

Ejemplo: Calcular Prima Pura de Riesgo.

```{r}
#| label: funcion-propia

calc_prima <- function(frecuencia, severidad, gastos = 0) {
  pura <- frecuencia * severidad
  comercial <- pura + gastos
  return(comercial)
}

# Probamos la función
calc_prima(frecuencia = 0.10, severidad = 5000, gastos = 50)
```

---

## 4. La Familia apply (Base R)

Para aplicar una función a cada elemento de una lista o matriz sin usar bucles for.

:::: {.columns}

::: {.column width="50%"} 
lapply (List Apply) Devuelve siempre una lista.

```{r}
nums <- list(a=10, b=20)
lapply(nums, sqrt)
```

:::

::: {.column width="50%"} 
sapply (Simplify Apply) Intenta devolver un vector o matriz.
```{r}
sapply(nums, sqrt)
```
:::

::::

---

### apply para Matrices

Ideal para operaciones por filas (1) o columnas (2).

```{r}
#| label: apply-matriz

matriz_riesgos <- matrix(1:9, nrow = 3)

# Sumar por FILAS (MARGIN = 1)
apply(matriz_riesgos, MARGIN = 1, sum)

# Promedio por COLUMNAS (MARGIN = 2)
apply(matriz_riesgos, MARGIN = 2, mean)
```


---

## 5. Iteración con purrr (Tidyverse)

Es la evolución moderna de apply. Más consistente y predecible.

* map(): Devuelve lista (igual a lapply).

* map_dbl(): Devuelve vector numérico (double).

* map_chr(): Devuelve vector de texto.

```{r}
#| label: purrr
library(purrr)

lista_precios <- list(100, 200, 500)

# Aplicar descuento del 10% a cada elemento
# La virgulilla (~) indica una función anónima
# El punto (.x) representa el elemento actual
map_dbl(lista_precios, ~ .x * 0.90)
```

---

## Resumen de Flujo

* Lógica: if, else para decisiones puntuales. ifelse() para columnas de datos.

* Repetición: for (usar con moderación).

* Abstracción: Crea tus propias function().

* Iteración Funcional:

* Base: lapply, sapply.

* Tidyverse: map, map_dbl.

::: {.r-fit-text} 
¡Automatiza todo! 
:::
